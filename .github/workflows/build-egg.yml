name: Build Bluefin Egg

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  IMAGE_NAME: egg
  IMAGE_REGISTRY: ghcr.io/${{ github.repository_owner }}
  BST2_IMAGE: registry.gitlab.com/freedesktop-sdk/infrastructure/freedesktop-sdk-docker-images/bst2:f89b4aef847ef040b345acceda15a850219eb8f1
  CACHE_GRPC_PORT: 9092
  CACHE_HTTP_PORT: 8080

# On PRs: group by branch so new pushes cancel stale runs.
# On main: group by SHA so every push gets its own non-cancellable run.
# (GitHub cancels even pending/queued runs in the same group regardless of
#  cancel-in-progress when a newer run arrives, so main needs unique groups.)
concurrency:
  group: ${{ github.workflow }}-${{ github.event_name == 'pull_request' && github.ref || github.sha }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  build:
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: write
    steps:
      # ── Host-level setup ──────────────────────────────────────────────
      # These steps MUST run on the host, not inside the bst2 container.
      # We cannot use `container:` at job level because
      # ublue-os/remove-unwanted-software needs host filesystem access.

      - name: Free disk space
        uses: ublue-os/remove-unwanted-software@695eb75bc387dbcd9685a8e72d23439d8686cba6

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Pull BuildStream container image
        run: podman pull "$BST2_IMAGE"

      - name: Cache BuildStream sources
        uses: actions/cache@v4
        with:
          path: ~/.cache/buildstream/sources
          key: bst-sources-${{ hashFiles('elements/**/*.bst', 'project.conf') }}
          restore-keys: |
            bst-sources-

      - name: Disk space before build
        run: df -h /

      - name: Prepare BuildStream cache directory
        run: mkdir -p "$HOME/.cache/buildstream/sources"

      # ── Remote cache sidecar ──────────────────────────────────────────
      # bazel-remote speaks CAS gRPC (compatible with BuildStream) and
      # proxies to Cloudflare R2 via S3.

      - name: Start bazel-remote cache proxy
        env:
          R2_ACCESS_KEY: ${{ secrets.R2_ACCESS_KEY }}
          R2_SECRET_KEY: ${{ secrets.R2_SECRET_KEY }}
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
        run: |
          if [ -z "${R2_ACCESS_KEY}" ]; then
            echo "R2 secrets not configured, skipping cache proxy"
            exit 0
          fi

          curl -fsSL -o /tmp/bazel-remote \
            "https://github.com/buchgr/bazel-remote/releases/download/v2.6.1/bazel-remote-2.6.1-linux-amd64"
          echo "025d53aeb03a7fdd4a0e76262a5ae9eeee9f64d53ca510deff1c84cf3f276784  /tmp/bazel-remote" | sha256sum -c -
          chmod +x /tmp/bazel-remote

          /tmp/bazel-remote \
            --s3.endpoint="${R2_ENDPOINT}" \
            --s3.bucket="bst-cache" \
            --s3.prefix="cas" \
            --s3.auth_method=access_key \
            --s3.access_key_id="${R2_ACCESS_KEY}" \
            --s3.secret_access_key="${R2_SECRET_KEY}" \
            --dir=/tmp/bazel-remote-cache \
            --max_size=5 \
            --http_address="0.0.0.0:${CACHE_HTTP_PORT}" \
            --grpc_address="0.0.0.0:${CACHE_GRPC_PORT}" \
            > /tmp/bazel-remote.log 2>&1 &
          echo $! > /tmp/bazel-remote.pid

          # Health check: wait up to 30 seconds for the HTTP endpoint
          for i in $(seq 1 30); do
            if curl -sf "http://localhost:${CACHE_HTTP_PORT}/status" > /dev/null 2>&1; then
              echo "bazel-remote is healthy (attempt ${i})"
              exit 0
            fi
            sleep 1
          done
          echo "::error::bazel-remote failed to start within 30 seconds"
          cat /tmp/bazel-remote.log
          exit 1

      # ── Generate CI-specific BuildStream config ───────────────────────
      # Tuned per gnome-build-meta CI patterns:
      # - on-error: continue  -> find ALL failures, don't stop at first
      # - fetchers: 32        -> aggressive parallel downloads from cache
      # - builders: 1         -> GHA has 4 vCPUs; nproc/4 = 1
      # - retry-failed: True  -> auto-retry flaky builds
      # - error-lines: 80     -> generous error context in logs
      # - cache-buildtrees: never -> save disk (we only need final artifacts)

      - name: Generate BuildStream CI config
        run: |
          mkdir -p logs
          cat > buildstream-ci.conf <<'BSTCONF'
          scheduler:
            on-error: continue
            fetchers: 32
            builders: 1
            network-retries: 3

          logging:
            message-format: '[%{wallclock}][%{elapsed}][%{key}][%{element}] %{action} %{message}'
            error-lines: 80

          build:
            max-jobs: 0
            retry-failed: True

          cache:
            cache-buildtrees: never
          BSTCONF

          # If cache proxy is running, add it as an artifact remote.
          # type: storage is critical -- bazel-remote only implements CAS,
          # not Remote Asset API. Without this BuildStream silently disables
          # the remote entirely.
          if [ -f /tmp/bazel-remote.pid ]; then
            cat >> buildstream-ci.conf <<BSTPUSH
          artifacts:
            servers:
              - url: "grpc://localhost:${CACHE_GRPC_PORT}"
                type: storage
                push: true
          BSTPUSH
            cat buildstream-ci.conf
          fi

      # ── BuildStream build ─────────────────────────────────────────────
      # Runs inside the bst2 container with:
      # - --privileged: required for bubblewrap sandboxing
      # - --device /dev/fuse: required for buildbox-fuse (ext4 lacks reflinks)
      # - ulimit -n 1048576: buildbox-casd needs many file descriptors
      # - --no-interactive: prevent blocking on prompts in CI

      - name: Build OCI image with BuildStream
        run: |
          NETWORK_FLAG=""
          REMOTE_FLAG=""
          if [ -f /tmp/bazel-remote.pid ]; then
            NETWORK_FLAG="--network=host"
            REMOTE_FLAG="--artifact-remote=url=grpc://localhost:${CACHE_GRPC_PORT},type=storage"
          fi

          podman run --rm \
            --privileged \
            --device /dev/fuse \
            ${NETWORK_FLAG} \
            -e REMOTE_FLAG="${REMOTE_FLAG}" \
            -v "${{ github.workspace }}:/src:rw" \
            -v "$HOME/.cache/buildstream:/root/.cache/buildstream:rw" \
            -w /src \
            "$BST2_IMAGE" \
            bash -c '
              ulimit -n 1048576 || true
              bst --no-interactive \
                  --colors \
                  --config /src/buildstream-ci.conf \
                  --log-file /src/logs/build.log \
                  build \
                  ${REMOTE_FLAG} \
                  oci/bluefin.bst
            '
        timeout-minutes: 120

      # ── Push artifacts to remote cache ─────────────────────────────────
      # Safety net: ensures all artifacts are pushed even if incremental
      # push-during-build missed some.  Non-fatal.

      - name: Push artifacts to remote cache
        if: always()
        continue-on-error: true
        run: |
          if [ ! -f /tmp/bazel-remote.pid ]; then
            echo "Cache proxy not running, skipping push"
            exit 0
          fi

          podman run --rm \
            --privileged \
            --device /dev/fuse \
            --network=host \
            -e CACHE_GRPC_PORT="${CACHE_GRPC_PORT}" \
            -v "${{ github.workspace }}:/src:rw" \
            -v "$HOME/.cache/buildstream:/root/.cache/buildstream:rw" \
            -w /src \
            "$BST2_IMAGE" \
            bash -c '
              ulimit -n 1048576 || true
              bst --no-interactive \
                  --config /src/buildstream-ci.conf \
                  artifact push \
                  --artifact-remote=url=grpc://localhost:${CACHE_GRPC_PORT},type=storage \
                  --deps all \
                  oci/bluefin.bst
            '

      - name: Check cache proxy stats
        if: always()
        run: |
          if [ -f /tmp/bazel-remote.pid ]; then
            echo "=== bazel-remote status ==="
            curl -sf "http://localhost:${CACHE_HTTP_PORT}/status" || echo "status endpoint unreachable"
            echo ""
            echo "=== last 50 lines of bazel-remote log ==="
            tail -50 /tmp/bazel-remote.log 2>/dev/null || echo "no log file"
          else
            echo "Cache proxy was not running"
          fi

      - name: Disk space after build
        if: always()
        run: df -h /

      # ── Export OCI image ──────────────────────────────────────────────
      # Stream the OCI tar from BuildStream directly into podman on the
      # host. This avoids writing an intermediate tar file to disk.
      # Pattern: bst artifact checkout --tar - | podman load

      - name: Export OCI image from BuildStream
        id: export
        run: |
          LOADED=$(podman run --rm \
            --privileged \
            --device /dev/fuse \
            -v "${{ github.workspace }}:/src:rw" \
            -v "$HOME/.cache/buildstream:/root/.cache/buildstream:rw" \
            -w /src \
            "$BST2_IMAGE" \
            bash -c '
              ulimit -n 1048576 || true
              bst --no-interactive \
                  --config /src/buildstream-ci.conf \
                  artifact checkout --tar - oci/bluefin.bst
            ' | podman load)
          # podman load prints "Loaded image: <name>:<tag>" or "Loaded image(s): <id>"
          IMAGE_REF=$(echo "$LOADED" | grep -oP '(?<=Loaded image: ).*' || \
                      echo "$LOADED" | grep -oP '(?<=Loaded image\(s\): ).*')
          echo "image_ref=$IMAGE_REF" >> "$GITHUB_OUTPUT"
          echo "Loaded: $IMAGE_REF"

      - name: Verify image loaded
        run: podman images

      # ── Validation ────────────────────────────────────────────────────

      - name: Validate with bootc container lint
        run: |
          podman run --rm --privileged \
            -v /var/lib/containers:/var/lib/containers \
            "${{ steps.export.outputs.image_ref }}" \
            bootc container lint

      # ── Upload build logs ─────────────────────────────────────────────
      # Always upload, even on failure, so build failures can be diagnosed.

      - name: Upload build logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: buildstream-logs
          path: logs/
          retention-days: 7
          if-no-files-found: ignore

      # ── Cache proxy cleanup ────────────────────────────────────────────

      - name: Upload cache proxy logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bazel-remote-logs
          path: /tmp/bazel-remote.log
          retention-days: 7
          if-no-files-found: ignore

      - name: Stop cache proxy
        if: always()
        run: |
          if [ -f /tmp/bazel-remote.pid ]; then
            PID=$(cat /tmp/bazel-remote.pid)
            if kill -0 "${PID}" 2>/dev/null; then
              echo "Stopping bazel-remote (PID ${PID})"
              kill "${PID}" || true
              wait "${PID}" 2>/dev/null || true
            fi
            rm -f /tmp/bazel-remote.pid
          fi

      # ── Publish to GHCR (main branch only) ───────────────────────────

      - name: Login to GHCR
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | \
            podman login ghcr.io --username ${{ github.actor }} --password-stdin

      - name: Tag image for GHCR
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          podman tag "${{ steps.export.outputs.image_ref }}" \
            "${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:latest" \
            "${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"

      - name: Push to GHCR
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          podman push --retry 3 "${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          podman push --retry 3 "${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
